"""
Module x·ª≠ l√Ω vi·ªác d·ªãch t√™n s·∫£n ph·∫©m gi·ªØa ti·∫øng Vi·ªát v√† ti·∫øng Anh
H·ªó tr·ª£ t√¨m ki·∫øm s·∫£n ph·∫©m b·∫±ng c·∫£ t√™n ti·∫øng Vi·ªát v√† ti·∫øng Anh
ƒê√£ ƒë∆∞·ª£c t·ªëi ∆∞u ƒë·ªÉ gi·∫£m s·ªë l·∫ßn g·ªçi LLM
"""
import re
from typing import Dict, List, Any, Optional, Tuple, Set
from functools import lru_cache

from ...utils.logger import log_info, log_error
from ...llm_clients.gemini_client import gemini_client
from ...utils.llm_counter import count_llm_call
from ...utils.vietnamese_to_english_mapping import translate_vietnamese_to_english, translate_english_to_vietnamese

# Cache cho vi·ªác d·ªãch t√™n s·∫£n ph·∫©m
TRANSLATION_CACHE = {
    'vi_to_en': {},  # Ti·∫øng Vi·ªát sang ti·∫øng Anh
    'en_to_vi': {}   # Ti·∫øng Anh sang ti·∫øng Vi·ªát
}

# B·∫£ng √°nh x·∫° t√™n s·∫£n ph·∫©m ti·∫øng Anh sang ti·∫øng Vi·ªát
PRODUCT_NAME_EN_TO_VI = {
    # C√† ph√™
    "brewed coffee": "c√† ph√™ phin",
    "caff√® latte": "c√† ph√™ s·ªØa",
    "caff√® mocha": "c√† ph√™ mocha",
    "vanilla latte": "c√† ph√™ s·ªØa vani",
    "caff√® americano": "c√† ph√™ americano",
    "cappuccino": "c√† ph√™ cappuccino",
    "espresso": "c√† ph√™ espresso",
    "skinny latte": "c√† ph√™ s·ªØa √≠t b√©o",
    "caramel macchiato": "c√† ph√™ caramel macchiato",
    "white chocolate mocha": "c√† ph√™ mocha s√¥ c√¥ la tr·∫Øng",
    "hot chocolate": "s√¥ c√¥ la n√≥ng",
    "iced brewed coffee": "c√† ph√™ phin ƒë√°",
    "iced brewed coffee with milk": "c√† ph√™ phin s·ªØa ƒë√°",

    # ƒê√° xay (Frappuccino)
    "coffee frappuccino": "c√† ph√™ ƒë√° xay",
    "mocha frappuccino": "mocha ƒë√° xay",
    "caramel frappuccino": "caramel ƒë√° xay",
    "java chip frappuccino": "java chip ƒë√° xay",
    "coffee light frappuccino": "c√† ph√™ ƒë√° xay √≠t b√©o",
    "mocha light frappuccino": "mocha ƒë√° xay √≠t b√©o",
    "caramel light frappuccino": "caramel ƒë√° xay √≠t b√©o",
    "frappuccino": "ƒë√° xay",
    "frappe": "ƒë√° xay",

    # Sinh t·ªë (Smoothie)
    "banana chocolate smoothie": "sinh t·ªë chu·ªëi s√¥ c√¥ la",
    "orange mango banana smoothie": "sinh t·ªë cam xo√†i chu·ªëi",
    "strawberry banana smoothie": "sinh t·ªë d√¢u chu·ªëi",
    "smoothie": "sinh t·ªë",

    # Tr√† (Tea)
    "tazo chai tea latte": "tr√† chai s·ªØa",
    "tazo green tea latte": "tr√† xanh s·ªØa",
    "shaken iced tazo tea": "tr√† ƒë√° l·∫Øc",
    "shaken iced tazo tea lemonade": "tr√† chanh ƒë√° l·∫Øc",
    "tea": "tr√†",
    "green tea": "tr√† xanh",
    "black tea": "tr√† ƒëen",
    "oolong tea": "tr√† √¥ long",
    "jasmine tea": "tr√† hoa l√†i",
    "earl grey": "tr√† earl grey",
    "chai tea": "tr√† chai",
    "matcha": "tr√† xanh matcha",
    "herbal tea": "tr√† th·∫£o m·ªôc",

    # Tr√† s·ªØa
    "milk tea": "tr√† s·ªØa",
    "bubble tea": "tr√† s·ªØa tr√¢n ch√¢u",
    "boba tea": "tr√† s·ªØa tr√¢n ch√¢u",
    "pearl milk tea": "tr√† s·ªØa tr√¢n ch√¢u",
    "taro milk tea": "tr√† s·ªØa khoai m√¥n",
    "thai milk tea": "tr√† s·ªØa th√°i",

    # ƒê·ªì u·ªëng kh√°c
    "caramel apple spice": "t√°o caramel gia v·ªã",
    "strawberries & cr√®me": "kem d√¢u",
    "vanilla bean": "kem vani",

    # T·ª´ kh√≥a chung
    "coffee": "c√† ph√™",
    "espresso": "c√† ph√™ espresso",
    "americano": "c√† ph√™ americano",
    "latte": "c√† ph√™ s·ªØa",
    "cappuccino": "c√† ph√™ cappuccino",
    "mocha": "c√† ph√™ mocha",
    "macchiato": "c√† ph√™ macchiato",
    "flat white": "c√† ph√™ flat white",
    "cold brew": "c√† ph√™ ·ªß l·∫°nh",
    "iced coffee": "c√† ph√™ ƒë√°",
    "vietnamese coffee": "c√† ph√™ vi·ªát nam",

    # N∆∞·ªõc √©p
    "juice": "n∆∞·ªõc √©p",
    "orange juice": "n∆∞·ªõc cam",
    "apple juice": "n∆∞·ªõc t√°o",
    "watermelon juice": "n∆∞·ªõc d∆∞a h·∫•u",
    "pineapple juice": "n∆∞·ªõc d·ª©a",
    "carrot juice": "n∆∞·ªõc √©p c√† r·ªët",
    "mixed juice": "n∆∞·ªõc √©p h·ªón h·ª£p",

    # Soda
    "soda": "soda",
    "sparkling water": "n∆∞·ªõc c√≥ ga",
    "lemon soda": "soda chanh",
    "strawberry soda": "soda d√¢u",
    "peach soda": "soda ƒë√†o",
    "passion fruit soda": "soda chanh d√¢y"
}

# B·∫£ng √°nh x·∫° t√™n s·∫£n ph·∫©m ti·∫øng Vi·ªát sang ti·∫øng Anh
PRODUCT_NAME_VI_TO_EN = {v: k for k, v in PRODUCT_NAME_EN_TO_VI.items()}

# B·ªï sung th√™m m·ªôt s·ªë t√™n s·∫£n ph·∫©m ti·∫øng Vi·ªát ph·ªï bi·∫øn
PRODUCT_NAME_VI_TO_EN.update({
    "c√† ph√™ ƒëen": "black coffee",
    "c√† ph√™ s·ªØa ƒë√°": "iced milk coffee",
    "b·∫°c x·ªâu": "vietnamese white coffee",
    "tr√† ƒë√†o": "peach tea",
    "tr√† v·∫£i": "lychee tea",
    "tr√† chanh": "lemon tea",
    "tr√† s·ªØa truy·ªÅn th·ªëng": "traditional milk tea",
    "tr√† s·ªØa matcha": "matcha milk tea",
    "tr√† s·ªØa socola": "chocolate milk tea",
    "sinh t·ªë vi·ªát qu·∫•t": "blueberry smoothie",
    "sinh t·ªë d·ª´a": "coconut smoothie",
    "n∆∞·ªõc √©p cam": "orange juice",
    "n∆∞·ªõc √©p t√°o": "apple juice",
    "n∆∞·ªõc √©p d·ª©a": "pineapple juice",
    "ƒë√° xay c√† ph√™": "coffee frappe",
    "ƒë√° xay tr√† xanh": "green tea frappe",
    "soda chanh": "lemon soda"
})

def translate_product_name(product_name: str, target_language: str = "vi") -> str:
    """
    D·ªãch t√™n s·∫£n ph·∫©m sang ng√¥n ng·ªØ ƒë√≠ch
    S·ª≠ d·ª•ng cache ƒë·ªÉ tr√°nh d·ªãch l·∫°i c√°c t√™n ƒë√£ d·ªãch tr∆∞·ªõc ƒë√≥

    Args:
        product_name (str): T√™n s·∫£n ph·∫©m c·∫ßn d·ªãch
        target_language (str): Ng√¥n ng·ªØ ƒë√≠ch ("vi" ho·∫∑c "en")

    Returns:
        str: T√™n s·∫£n ph·∫©m ƒë√£ ƒë∆∞·ª£c d·ªãch
    """
    if not product_name:
        return ""

    product_name = product_name.lower().strip()

    # Ki·ªÉm tra cache tr∆∞·ªõc
    cache_key = 'en_to_vi' if target_language == "vi" else 'vi_to_en'
    if product_name in TRANSLATION_CACHE[cache_key]:
        log_info(f"üîÑ Cache hit for '{product_name}' -> '{TRANSLATION_CACHE[cache_key][product_name]}'")
        return TRANSLATION_CACHE[cache_key][product_name]

    result = None

    if target_language == "vi":
        # D·ªãch t·ª´ ti·∫øng Anh sang ti·∫øng Vi·ªát
        if product_name in PRODUCT_NAME_EN_TO_VI:
            result = PRODUCT_NAME_EN_TO_VI[product_name]
        else:
            # T√¨m ki·∫øm kh·ªõp ch√≠nh x√°c tr∆∞·ªõc
            for en_name, vi_name in PRODUCT_NAME_EN_TO_VI.items():
                if en_name == product_name:
                    result = vi_name
                    break

            # N·∫øu kh√¥ng t√¨m th·∫•y kh·ªõp ch√≠nh x√°c, t√¨m ki·∫øm kh·ªõp m·ªôt ph·∫ßn
            if not result:
                for en_name, vi_name in PRODUCT_NAME_EN_TO_VI.items():
                    # Ch·ªâ kh·ªõp n·∫øu t·ª´ kh√≥a l√† m·ªôt ph·∫ßn ƒë√°ng k·ªÉ c·ªßa t√™n s·∫£n ph·∫©m
                    if (en_name in product_name and len(en_name) >= 4) or (product_name in en_name and len(product_name) >= 4):
                        result = vi_name
                        break
    else:
        # D·ªãch t·ª´ ti·∫øng Vi·ªát sang ti·∫øng Anh
        if product_name in PRODUCT_NAME_VI_TO_EN:
            result = PRODUCT_NAME_VI_TO_EN[product_name]
        else:
            # T√¨m ki·∫øm kh·ªõp ch√≠nh x√°c tr∆∞·ªõc
            for vi_name, en_name in PRODUCT_NAME_VI_TO_EN.items():
                if vi_name == product_name:
                    result = en_name
                    break

            # N·∫øu kh√¥ng t√¨m th·∫•y kh·ªõp ch√≠nh x√°c, t√¨m ki·∫øm kh·ªõp m·ªôt ph·∫ßn
            if not result:
                for vi_name, en_name in PRODUCT_NAME_VI_TO_EN.items():
                    # Ch·ªâ kh·ªõp n·∫øu t·ª´ kh√≥a l√† m·ªôt ph·∫ßn ƒë√°ng k·ªÉ c·ªßa t√™n s·∫£n ph·∫©m
                    if (vi_name in product_name and len(vi_name) >= 4) or (product_name in vi_name and len(product_name) >= 4):
                        result = en_name
                        break

    # N·∫øu kh√¥ng t√¨m th·∫•y trong b·∫£ng √°nh x·∫°, s·ª≠ d·ª•ng LLM ƒë·ªÉ d·ªãch
    if not result:
        result = _translate_with_llm(product_name, target_language)

    # L∆∞u v√†o cache
    TRANSLATION_CACHE[cache_key][product_name] = result

    return result

def get_all_product_name_variations(product_name: str) -> Set[str]:
    """
    L·∫•y t·∫•t c·∫£ c√°c bi·∫øn th·ªÉ c·ªßa t√™n s·∫£n ph·∫©m (c·∫£ ti·∫øng Vi·ªát v√† ti·∫øng Anh)
    ƒê√£ ƒë∆∞·ª£c t·ªëi ∆∞u ƒë·ªÉ gi·∫£m s·ªë l·∫ßn g·ªçi LLM

    Args:
        product_name (str): T√™n s·∫£n ph·∫©m g·ªëc

    Returns:
        Set[str]: T·∫≠p h·ª£p c√°c bi·∫øn th·ªÉ c·ªßa t√™n s·∫£n ph·∫©m
    """
    if not product_name:
        return set()

    # Ki·ªÉm tra cache
    cache_key = 'variations'
    if not hasattr(TRANSLATION_CACHE, cache_key):
        TRANSLATION_CACHE[cache_key] = {}

    product_name_lower = product_name.lower().strip()

    # Ki·ªÉm tra cache tr∆∞·ªõc
    if product_name_lower in TRANSLATION_CACHE[cache_key]:
        log_info(f"üîÑ Cache hit for variations of '{product_name_lower}'")
        return TRANSLATION_CACHE[cache_key][product_name_lower]

    variations = {product_name_lower}

    # X√°c ƒë·ªãnh ng√¥n ng·ªØ c·ªßa t√™n s·∫£n ph·∫©m
    is_vietnamese = any(char in "√†√°·∫°·∫£√£√¢·∫ß·∫•·∫≠·∫©·∫´ƒÉ·∫±·∫Ø·∫∑·∫≥·∫µ√®√©·∫π·∫ª·∫Ω√™·ªÅ·∫ø·ªá·ªÉ·ªÖ√¨√≠·ªã·ªâƒ©√≤√≥·ªç·ªè√µ√¥·ªì·ªë·ªô·ªï·ªó∆°·ªù·ªõ·ª£·ªü·ª°√π√∫·ª•·ªß≈©∆∞·ª´·ª©·ª±·ª≠·ªØ·ª≥√Ω·ªµ·ª∑·ªπƒë" for char in product_name_lower)

    # Th√™m b·∫£n d·ªãch sang ng√¥n ng·ªØ kh√°c
    if is_vietnamese:
        # D·ªãch t·ª´ ti·∫øng Vi·ªát sang ti·∫øng Anh
        en_translation = translate_product_name(product_name_lower, "en")
        if en_translation != product_name_lower:
            variations.add(en_translation)
    else:
        # D·ªãch t·ª´ ti·∫øng Anh sang ti·∫øng Vi·ªát
        vi_translation = translate_product_name(product_name_lower, "vi")
        if vi_translation != product_name_lower:
            variations.add(vi_translation)

    # Th√™m c√°c bi·∫øn th·ªÉ ph·ªï bi·∫øn (ch·ªâ th√™m t·ªëi ƒëa 3 bi·∫øn th·ªÉ)
    common_variations = _generate_common_variations(product_name_lower)
    for variation in common_variations[:3]:
        variations.add(variation)

    # L∆∞u v√†o cache
    TRANSLATION_CACHE[cache_key][product_name_lower] = variations

    return variations

def enhance_product_search_query(query: str) -> str:
    """
    TƒÉng c∆∞·ªùng c√¢u truy v·∫•n t√¨m ki·∫øm s·∫£n ph·∫©m b·∫±ng c√°ch th√™m c√°c bi·∫øn th·ªÉ t√™n s·∫£n ph·∫©m
    ƒê√£ ƒë∆∞·ª£c t·ªëi ∆∞u ƒë·ªÉ gi·∫£m s·ªë l·∫ßn g·ªçi LLM v√† t·∫≠p trung v√†o c√°c bi·∫øn th·ªÉ c√≥ √Ω nghƒ©a

    Args:
        query (str): C√¢u truy v·∫•n g·ªëc

    Returns:
        str: C√¢u truy v·∫•n ƒë√£ ƒë∆∞·ª£c tƒÉng c∆∞·ªùng
    """
    # Ki·ªÉm tra cache
    cache_key = 'enhanced_queries'
    if not hasattr(TRANSLATION_CACHE, cache_key):
        TRANSLATION_CACHE[cache_key] = {}

    # Ki·ªÉm tra cache tr∆∞·ªõc
    if query in TRANSLATION_CACHE[cache_key]:
        log_info(f"üîÑ Cache hit for enhanced query: '{query}'")
        return TRANSLATION_CACHE[cache_key][query]

    # T√¨m c√°c t√™n s·∫£n ph·∫©m trong c√¢u truy v·∫•n
    product_names = _extract_product_names_from_query(query)

    if not product_names:
        return query

    # T·∫°o c√¢u truy v·∫•n m·ªõi v·ªõi c√°c bi·∫øn th·ªÉ t√™n s·∫£n ph·∫©m
    enhanced_query = query

    for product_name in product_names:
        # L·∫•y t·ªëi ƒëa 3 bi·∫øn th·ªÉ cho m·ªói t√™n s·∫£n ph·∫©m
        variations = list(get_all_product_name_variations(product_name))[:3]

        # Lo·∫°i b·ªè t√™n s·∫£n ph·∫©m g·ªëc kh·ªèi variations
        if product_name in variations:
            variations.remove(product_name)

        # Th√™m c√°c bi·∫øn th·ªÉ v√†o c√¢u truy v·∫•n
        if variations:
            variation_str = " OR ".join([f'"{v}"' for v in variations])
            enhanced_query = enhanced_query.replace(product_name, f'({product_name} OR {variation_str})')

    # L∆∞u v√†o cache
    TRANSLATION_CACHE[cache_key][query] = enhanced_query

    return enhanced_query

def generate_cypher_product_name_condition(product_name: str) -> str:
    """
    T·∫°o ƒëi·ªÅu ki·ªán Cypher cho t√™n s·∫£n ph·∫©m, bao g·ªìm c·∫£ t√™n ti·∫øng Vi·ªát v√† ti·∫øng Anh
    ƒê√£ ƒë∆∞·ª£c t·ªëi ∆∞u ƒë·ªÉ gi·∫£m s·ªë l·∫ßn g·ªçi LLM v√† t·∫°o ƒëi·ªÅu ki·ªán Cypher hi·ªáu qu·∫£ h∆°n

    Args:
        product_name (str): T√™n s·∫£n ph·∫©m

    Returns:
        str: ƒêi·ªÅu ki·ªán Cypher
    """
    if not product_name:
        return "true"  # ƒêi·ªÅu ki·ªán lu√¥n ƒë√∫ng n·∫øu kh√¥ng c√≥ t√™n s·∫£n ph·∫©m

    # Ki·ªÉm tra cache
    cache_key = 'cypher_conditions'
    if not hasattr(TRANSLATION_CACHE, cache_key):
        TRANSLATION_CACHE[cache_key] = {}

    product_name_lower = product_name.lower().strip()

    # Ki·ªÉm tra cache tr∆∞·ªõc
    if product_name_lower in TRANSLATION_CACHE[cache_key]:
        log_info(f"üîÑ Cache hit for Cypher condition: '{product_name_lower}'")
        return TRANSLATION_CACHE[cache_key][product_name_lower]

    # L·∫•y t·ªëi ƒëa 3 bi·∫øn th·ªÉ cho t√™n s·∫£n ph·∫©m
    variations = list(get_all_product_name_variations(product_name))[:3]

    # ƒê·∫£m b·∫£o t√™n s·∫£n ph·∫©m g·ªëc c√≥ trong variations
    if product_name_lower not in variations:
        variations.insert(0, product_name_lower)

    # T·∫°o ƒëi·ªÅu ki·ªán Cypher
    conditions = []
    for variation in variations:
        # S·ª≠ d·ª•ng regex matching (=~) thay v√¨ CONTAINS
        # Th√™m k√Ω t·ª± escape cho c√°c k√Ω t·ª± ƒë·∫∑c bi·ªát trong regex
        escaped_variation = re.escape(variation)
        conditions.append(f'p.name =~ "(?i).*{escaped_variation}.*"')

    cypher_condition = "(" + " OR ".join(conditions) + ")"

    # L∆∞u v√†o cache
    TRANSLATION_CACHE[cache_key][product_name_lower] = cypher_condition

    return cypher_condition

@count_llm_call
def _translate_with_llm(text: str, target_language: str = "vi") -> str:
    """
    S·ª≠ d·ª•ng LLM ƒë·ªÉ d·ªãch vƒÉn b·∫£n
    ƒê√£ ƒë∆∞·ª£c t·ªëi ∆∞u ƒë·ªÉ gi·∫£m s·ªë l·∫ßn g·ªçi LLM

    Args:
        text (str): VƒÉn b·∫£n c·∫ßn d·ªãch
        target_language (str): Ng√¥n ng·ªØ ƒë√≠ch ("vi" ho·∫∑c "en")

    Returns:
        str: VƒÉn b·∫£n ƒë√£ ƒë∆∞·ª£c d·ªãch
    """
    if not text:
        return ""

    text = text.lower().strip()

    # Ki·ªÉm tra cache tr∆∞·ªõc
    cache_key = 'en_to_vi' if target_language == "vi" else 'vi_to_en'
    if text in TRANSLATION_CACHE[cache_key]:
        log_info(f"üîÑ Cache hit for translation '{text}' -> '{TRANSLATION_CACHE[cache_key][text]}'")
        return TRANSLATION_CACHE[cache_key][text]

    # Ki·ªÉm tra b·∫£ng √°nh x·∫° tr∆∞·ªõc khi g·ªçi LLM
    if target_language == "vi" and text in PRODUCT_NAME_EN_TO_VI:
        translation = PRODUCT_NAME_EN_TO_VI[text]
        TRANSLATION_CACHE[cache_key][text] = translation
        return translation
    elif target_language == "en" and text in PRODUCT_NAME_VI_TO_EN:
        translation = PRODUCT_NAME_VI_TO_EN[text]
        TRANSLATION_CACHE[cache_key][text] = translation
        return translation

    # Ki·ªÉm tra xem c√≥ th·ªÉ t√¨m th·∫•y m·ªôt ph·∫ßn trong b·∫£ng √°nh x·∫° kh√¥ng
    if target_language == "vi":
        for en_name, vi_name in PRODUCT_NAME_EN_TO_VI.items():
            if (en_name in text and len(en_name) >= 4) or (text in en_name and len(text) >= 4):
                TRANSLATION_CACHE[cache_key][text] = vi_name
                return vi_name
    else:
        for vi_name, en_name in PRODUCT_NAME_VI_TO_EN.items():
            if (vi_name in text and len(vi_name) >= 4) or (text in vi_name and len(text) >= 4):
                TRANSLATION_CACHE[cache_key][text] = en_name
                return en_name

    # N·∫øu kh√¥ng t√¨m th·∫•y trong b·∫£ng √°nh x·∫°, s·ª≠ d·ª•ng LLM ƒë·ªÉ d·ªãch
    try:
        language = "Vietnamese" if target_language == "vi" else "English"

        prompt = f"""Translate the following beverage name to {language}. Keep it concise and natural:

        {text}

        Only return the translated name, nothing else."""

        # L∆∞u temperature hi·ªán t·∫°i
        current_temp = getattr(gemini_client, '_temperature', 0.0)

        try:
            # ƒê·∫∑t temperature th·∫•p cho vi·ªác d·ªãch
            gemini_client._temperature = 0.1

            # G·ªçi LLM ƒë·ªÉ d·ªãch
            response = gemini_client.generate_text(prompt)

            # Tr·∫£ v·ªÅ k·∫øt qu·∫£ d·ªãch
            translation = response.strip()
            log_info(f"üß† Translated '{text}' to '{translation}' using LLM")

            # L∆∞u v√†o cache
            TRANSLATION_CACHE[cache_key][text] = translation

            # C·∫≠p nh·∫≠t b·∫£ng √°nh x·∫° ƒë·ªÉ s·ª≠ d·ª•ng cho l·∫ßn sau
            if target_language == "vi":
                PRODUCT_NAME_EN_TO_VI[text] = translation
            else:
                PRODUCT_NAME_VI_TO_EN[text] = translation

            return translation

        finally:
            # Kh√¥i ph·ª•c temperature ban ƒë·∫ßu
            gemini_client._temperature = current_temp

    except Exception as e:
        log_error(f"Error translating with LLM: {str(e)}")
        return text

def _generate_common_variations(product_name: str) -> List[str]:
    """
    T·∫°o c√°c bi·∫øn th·ªÉ ph·ªï bi·∫øn c·ªßa t√™n s·∫£n ph·∫©m
    ƒê√£ ƒë∆∞·ª£c t·ªëi ∆∞u ƒë·ªÉ t·∫°o √≠t bi·∫øn th·ªÉ h∆°n v√† t·∫≠p trung v√†o c√°c bi·∫øn th·ªÉ c√≥ √Ω nghƒ©a

    Args:
        product_name (str): T√™n s·∫£n ph·∫©m g·ªëc

    Returns:
        List[str]: Danh s√°ch c√°c bi·∫øn th·ªÉ
    """
    variations = []
    product_name_lower = product_name.lower()

    # B·∫£ng √°nh x·∫° c√°c ti·ªÅn t·ªë v√† h·∫≠u t·ªë ph·ªï bi·∫øn
    common_prefixes = {
        "c√† ph√™": ["espresso", "latte", "cappuccino", "americano", "mocha", "macchiato"],
        "tr√†": ["green tea", "black tea", "oolong tea", "jasmine tea", "earl grey", "chai tea"],
        "sinh t·ªë": ["smoothie"],
        "n∆∞·ªõc √©p": ["juice"],
        "ƒë√° xay": ["frappuccino", "frappe"],
        "tr√† s·ªØa": ["milk tea", "bubble tea", "boba tea"]
    }

    common_suffixes = {
        "ƒë√°": ["iced"],
        "n√≥ng": ["hot"],
        "√≠t ƒë∆∞·ªùng": ["less sugar", "low sugar"],
        "kh√¥ng ƒë∆∞·ªùng": ["no sugar", "sugar-free"],
        "s·ªØa": ["milk", "with milk"]
    }

    # X·ª≠ l√Ω c√°c ti·ªÅn t·ªë
    for vi_prefix, en_prefixes in common_prefixes.items():
        # N·∫øu t√™n s·∫£n ph·∫©m b·∫Øt ƒë·∫ßu b·∫±ng ti·ªÅn t·ªë ti·∫øng Vi·ªát, th√™m phi√™n b·∫£n kh√¥ng c√≥ ti·ªÅn t·ªë
        if product_name_lower.startswith(vi_prefix + " "):
            suffix = product_name_lower[len(vi_prefix) + 1:]
            if len(suffix) >= 3:  # Ch·ªâ th√™m n·∫øu ph·∫ßn c√≤n l·∫°i ƒë·ªß d√†i
                variations.append(suffix)

        # N·∫øu t√™n s·∫£n ph·∫©m b·∫Øt ƒë·∫ßu b·∫±ng ti·ªÅn t·ªë ti·∫øng Anh, th√™m phi√™n b·∫£n v·ªõi ti·ªÅn t·ªë ti·∫øng Vi·ªát
        for en_prefix in en_prefixes:
            if product_name_lower.startswith(en_prefix + " "):
                suffix = product_name_lower[len(en_prefix) + 1:]
                if len(suffix) >= 3:  # Ch·ªâ th√™m n·∫øu ph·∫ßn c√≤n l·∫°i ƒë·ªß d√†i
                    variations.append(vi_prefix + " " + suffix)

    # X·ª≠ l√Ω c√°c h·∫≠u t·ªë
    for vi_suffix, en_suffixes in common_suffixes.items():
        # N·∫øu t√™n s·∫£n ph·∫©m k·∫øt th√∫c b·∫±ng h·∫≠u t·ªë ti·∫øng Vi·ªát, th√™m phi√™n b·∫£n kh√¥ng c√≥ h·∫≠u t·ªë
        if product_name_lower.endswith(" " + vi_suffix):
            prefix = product_name_lower[:-len(vi_suffix) - 1]
            if len(prefix) >= 3:  # Ch·ªâ th√™m n·∫øu ph·∫ßn c√≤n l·∫°i ƒë·ªß d√†i
                variations.append(prefix)

        # N·∫øu t√™n s·∫£n ph·∫©m k·∫øt th√∫c b·∫±ng h·∫≠u t·ªë ti·∫øng Anh, th√™m phi√™n b·∫£n v·ªõi h·∫≠u t·ªë ti·∫øng Vi·ªát
        for en_suffix in en_suffixes:
            if product_name_lower.endswith(" " + en_suffix):
                prefix = product_name_lower[:-len(en_suffix) - 1]
                if len(prefix) >= 3:  # Ch·ªâ th√™m n·∫øu ph·∫ßn c√≤n l·∫°i ƒë·ªß d√†i
                    variations.append(prefix + " " + vi_suffix)

    # X·ª≠ l√Ω c√°c tr∆∞·ªùng h·ª£p ƒë·∫∑c bi·ªát
    special_cases = {
        "c√† ph√™ s·ªØa ƒë√°": ["iced milk coffee", "iced latte", "c√† ph√™ s·ªØa", "c√† ph√™ ƒë√°"],
        "c√† ph√™ ƒëen ƒë√°": ["iced black coffee", "c√† ph√™ ƒëen", "c√† ph√™ ƒë√°"],
        "tr√† s·ªØa tr√¢n ch√¢u": ["bubble milk tea", "boba milk tea", "pearl milk tea", "tr√† s·ªØa"],
        "sinh t·ªë xo√†i": ["mango smoothie", "sinh t·ªë"],
        "n∆∞·ªõc cam": ["orange juice", "n∆∞·ªõc √©p cam"]
    }

    # Th√™m c√°c bi·∫øn th·ªÉ ƒë·∫∑c bi·ªát n·∫øu t√™n s·∫£n ph·∫©m kh·ªõp
    for case, case_variations in special_cases.items():
        if product_name_lower == case:
            variations.extend(case_variations)
            break

    # Lo·∫°i b·ªè c√°c bi·∫øn th·ªÉ tr√πng l·∫∑p v√† t√™n g·ªëc
    unique_variations = []
    for variation in variations:
        if variation != product_name_lower and variation not in unique_variations:
            unique_variations.append(variation)

    return unique_variations

def _remove_redundant_product_names(product_names: List[str]) -> List[str]:
    """
    Lo·∫°i b·ªè c√°c t√™n s·∫£n ph·∫©m tr√πng l·∫∑p ho·∫∑c l√† ph·∫ßn con c·ªßa t√™n kh√°c

    Args:
        product_names (List[str]): Danh s√°ch t√™n s·∫£n ph·∫©m

    Returns:
        List[str]: Danh s√°ch t√™n s·∫£n ph·∫©m ƒë√£ ƒë∆∞·ª£c l·ªçc
    """
    if not product_names:
        return []

    # S·∫Øp x·∫øp t√™n s·∫£n ph·∫©m theo ƒë·ªô d√†i gi·∫£m d·∫ßn
    sorted_names = sorted(product_names, key=len, reverse=True)

    # Danh s√°ch k·∫øt qu·∫£
    result = []

    # Th√™m t√™n s·∫£n ph·∫©m d√†i nh·∫•t v√†o k·∫øt qu·∫£
    result.append(sorted_names[0])

    # Ki·ªÉm tra c√°c t√™n s·∫£n ph·∫©m c√≤n l·∫°i
    for name in sorted_names[1:]:
        # Ki·ªÉm tra xem t√™n s·∫£n ph·∫©m c√≥ l√† ph·∫ßn con c·ªßa t√™n n√†o ƒë√≥ trong k·∫øt qu·∫£ kh√¥ng
        is_substring = False
        for existing_name in result:
            if name in existing_name:
                is_substring = True
                break

        # N·∫øu kh√¥ng ph·∫£i l√† ph·∫ßn con, th√™m v√†o k·∫øt qu·∫£
        if not is_substring:
            result.append(name)

    return result

def _extract_product_names_from_query(query: str) -> List[str]:
    """
    Tr√≠ch xu·∫•t t√™n s·∫£n ph·∫©m t·ª´ c√¢u truy v·∫•n
    ƒê√£ ƒë∆∞·ª£c t·ªëi ∆∞u ƒë·ªÉ tr√≠ch xu·∫•t c·ª•m t·ª´ ho√†n ch·ªânh v√† gi·∫£m s·ªë l·∫ßn g·ªçi LLM

    Args:
        query (str): C√¢u truy v·∫•n

    Returns:
        List[str]: Danh s√°ch t√™n s·∫£n ph·∫©m
    """
    if not query:
        return []

    # Ki·ªÉm tra cache
    cache_key = 'extracted_products'
    if not hasattr(TRANSLATION_CACHE, cache_key):
        TRANSLATION_CACHE[cache_key] = {}

    query_lower = query.lower().strip()

    # Ki·ªÉm tra cache tr∆∞·ªõc
    if query_lower in TRANSLATION_CACHE[cache_key]:
        log_info(f"üîÑ Cache hit for extracted products from: '{query_lower}'")
        return TRANSLATION_CACHE[cache_key][query_lower]

    product_names = []

    # B∆∞·ªõc 1: T√¨m ki·∫øm c√°c c·ª•m t·ª´ ho√†n ch·ªânh tr∆∞·ªõc
    # Danh s√°ch c√°c c·ª•m t·ª´ c·ª• th·ªÉ ƒë·ªÉ t√¨m ki·∫øm
    specific_product_patterns = [
        # C√† ph√™
        r"c√† ph√™\s+(?:s·ªØa|ƒëen|ƒë√°|n√≥ng|phin|espresso|latte|mocha|americano|cappuccino)(?:\s+(?:ƒë√°|n√≥ng|√≠t ƒë∆∞·ªùng|kh√¥ng ƒë∆∞·ªùng|√≠t s·ªØa))*",
        r"(?:brewed|iced)\s+coffee(?:\s+with\s+(?:milk|sugar|cream))?",
        r"(?:caff√®|caffe)\s+(?:latte|mocha|americano)",
        r"(?:vanilla|caramel)\s+latte",
        r"(?:cappuccino|espresso|macchiato)",
        r"(?:white\s+chocolate\s+mocha)",

        # Tr√†
        r"tr√†\s+(?:xanh|ƒëen|s·ªØa|ƒë√†o|v·∫£i|chanh|hoa l√†i|√¥ long|matcha)(?:\s+(?:ƒë√°|n√≥ng|√≠t ƒë∆∞·ªùng|kh√¥ng ƒë∆∞·ªùng))*",
        r"(?:green|black|oolong|jasmine|earl grey|chai)\s+tea",
        r"(?:tazo\s+chai|tazo\s+green)\s+tea\s+latte",
        r"(?:shaken\s+iced\s+tazo)\s+tea(?:\s+lemonade)?",

        # Sinh t·ªë
        r"sinh t·ªë\s+(?:xo√†i|d√¢u|chu·ªëi|b∆°|d·ª´a|vi·ªát qu·∫•t|cam)(?:\s+(?:s·ªØa chua|s·ªØa|ƒë√°|√≠t ƒë∆∞·ªùng))*",
        r"(?:banana\s+chocolate|orange\s+mango\s+banana|strawberry\s+banana)\s+smoothie",
        r"(?:mango|strawberry|banana|avocado|coconut|blueberry|orange)\s+smoothie",

        # ƒê√° xay
        r"(?:c√† ph√™|mocha|caramel|java chip|tr√† xanh)\s+ƒë√° xay",
        r"(?:coffee|mocha|caramel|java chip)\s+(?:frappuccino|frappe)",

        # Tr√† s·ªØa
        r"tr√† s·ªØa\s+(?:tr√¢n ch√¢u|khoai m√¥n|th√°i|matcha|socola)(?:\s+(?:ƒë√°|n√≥ng|√≠t ƒë∆∞·ªùng|kh√¥ng ƒë∆∞·ªùng))*",
        r"(?:bubble|boba|pearl milk|taro milk|thai milk)\s+tea",

        # S√¥ c√¥ la
        r"s√¥ c√¥ la\s+(?:n√≥ng|ƒë√°)",
        r"hot\s+chocolate"
    ]

    # T√¨m ki·∫øm c√°c c·ª•m t·ª´ c·ª• th·ªÉ
    for pattern in specific_product_patterns:
        matches = re.findall(pattern, query_lower)
        for match in matches:
            if match and match not in product_names:
                product_names.append(match)

    # B∆∞·ªõc 2: N·∫øu kh√¥ng t√¨m th·∫•y c·ª•m t·ª´ c·ª• th·ªÉ, t√¨m ki·∫øm t·ª´ kh√≥a chung
    if not product_names:
        # Danh s√°ch c√°c t·ª´ kh√≥a ƒë·ªÉ t√¨m t√™n s·∫£n ph·∫©m
        prefixes = ["c√† ph√™", "tr√†", "tr√† s·ªØa", "sinh t·ªë", "n∆∞·ªõc √©p", "ƒë√° xay", "soda",
                    "coffee", "tea", "milk tea", "smoothie", "juice", "frappe", "frappuccino"]

        for prefix in prefixes:
            # T√¨m t√™n s·∫£n ph·∫©m v·ªõi prefix
            pattern = rf"{prefix}\s+(\w+(?:\s+\w+)*)"
            matches = re.findall(pattern, query_lower)

            if matches:
                for match in matches:
                    product_name = f"{prefix} {match}".strip()
                    if product_name not in product_names:
                        product_names.append(product_name)
            elif prefix in query_lower:
                # N·∫øu ch·ªâ c√≥ prefix m√† kh√¥ng c√≥ t·ª´ sau
                product_names.append(prefix)

    # B∆∞·ªõc 3: Lo·∫°i b·ªè c√°c t√™n s·∫£n ph·∫©m tr√πng l·∫∑p ho·∫∑c l√† ph·∫ßn con c·ªßa t√™n kh√°c
    if product_names:
        product_names = _remove_redundant_product_names(product_names)

    # L∆∞u v√†o cache
    TRANSLATION_CACHE[cache_key][query_lower] = product_names

    return product_names
